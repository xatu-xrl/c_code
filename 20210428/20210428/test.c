#include<stdio.h>
//位段
//后面有个冒号和数子
//struct A
//{
//	int _a: 2;//4 32 30
//	int _b :5;//25
//	int _c :10;//15
//	int _d :30;// 4 -32
//	//比特位
//};
//int main()
//{
//
//	printf("%d\n", sizeof(struct A));//8
//	return 0;
//}
//1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
//2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段
//4.位段数据的存储在vs是从低地址开始存放的。

//位段的跨平台问题
//1. int 位段被当成有符号数还是无符号数是不确定的。
//2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
//3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
//4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的

//网络协议 位段的应用

//枚举
//enum Color
//{
//	red,//0 默认是0 枚举常量
//	green,//1
//	blue//2
//};
//enum Sex
//{
//	male,
//	female,
//	secret
//};
//int main()
//{
//	enum Color c = red;
//	enum Sex sex = secret;
//	return 0;
//}
//枚举的优点：
//1. 增加代码的可读性和可维护性
//2. 和#define定义的标识符比较枚举有类型检查，更加严谨。
//3. 防止了命名污染（封装）
//4. 便于调试
//5. 使用方便，一次可以定义多个常量

//test.c 到 test.exe
//编译（） 链接

//联合（共用体）
union Un
{
	char c;
	int i;
};
int main()
{
	union Un u = { 0 };
	printf("%d\n", sizeof(u));//4 公用一块空间
	//最大对其数的整数倍
	return 0;
}